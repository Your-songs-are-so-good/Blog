{"posts":[{"title":"有关 Date 的解析","content":"javascript的 Date 参考了早期 java.utils.Date，但是自身提供的api接口不是很多，实际使用时需要自己进行封装或者使用现成的时间库 基本使用 浏览器控制台打印 Date 可以得到两种形式的方法，一是绑定在 Date 上的静态方法，一是继承的方法 Date.parse()、Date.UTC() 和 Date.now() Date.parse() 可以解析满足结构的时间字符串，返回毫秒数 Date.UTC() 可以解析满足如形如：Date.UTC(2022,7,3,22,0)，返回毫秒数 Date.now() 返回当前时间的毫秒数 创建一个Date实例 ( new Date ) 会根据参数类型和个数隐式调用上面三个函数中的一个 继承的方法 时间库使用 Day.js 时间库 Fast 2kB alternative to Moment.js with the same modern API All API operations that change the Day.js object will return a new instance instead 使用感悟：体积小，插件式便于扩展，结果独立，链式调用 ","link":"https://chenmi.online/blog/post/20220704/"},{"title":"在 Webpack 写一个 Loader","content":"前言 有的时候，你可能在从零搭建 Webpack 项目很熟悉，配置过各种 loader ，面试官在 Webpack 方面问你，是否自己实现过一个loader ？如果没有去了解过如果去实现，确实有点尴尬，其实呢，loader 实现其实很简单的。下面说下 loader 是什么？ 为什么需要Loader? Webpack 它只能处理 js 和 JSON 文件。面对 css 文件还有一些图片等等，Webpack 它自己是不能够处理的，它需要loader 处理其他类型的文件并将它们转换为有效的模块以供应用程序使用并添加到依赖关系图中 Loader是什么？ loader本质上是一个node模块，符合Webpack中一切皆模块的思想。由于它是一个 node 模块，它必须导出一些东西。loader本身就是一个函数，在该函数中对接收到的内容进行转换，然后返回转换后的结果 下面为你简单介绍下webpack中的loader 常见的loader 我们先来回顾下常见的 Loader 基础的配置和使用吧（仅仅只是常见的，npm上面开发者大佬们发布的太多了） 那么开始吧，首先先介绍 处理 CSS 相关的 Loader css-loader 和 style-loader 安装依赖 npm install css-loader style-loader -D 使用加载器 module.exports = { // ... module: { rules: [{ test: /\\.css$/, use: ['style-loader', 'css-loader'], }], }, }； 其中module.rules代表模块的处理规则。每个规则可以包含很多配置项 test 可以接收正则表达式或元素为正则表达式的数组。只有与正则表达式匹配的模块才会使用此规则。在此示例中，/.css$/ 匹配所有以 .css 结尾的文件 use 可以接收一个包含规则使用的加载器的数组。如果只配置了一个css-loader，当只有一个loader时也可以为字符串 css-loader 的作用只是处理 CSS 的各种加载语法（@import 和 url() 函数等），如果样式要工作，则需要 style-loader 将样式插入页面 style-loader加到了css-loader前面，这是因为在Webpack打包时是按照数组从后往前的顺序将资源交给loader处理的，因此要把最后生效的放在前面 还可以这样写成对象的形式，里面options传入配置 module.exports = { // ... module: { rules: [{ test: /\\.css$/, use: [ 'style-loader', { loader: 'css-loader', options: { // css-loader 配置项 }, } ], }], }, }； exclude与include include代表该规则只对正则匹配到的模块生效 exclude的含义是，所有被正则匹配到的模块都排除在该规则之外 rules: [ { test: /\\.css$/, use: ['style-loader', 'css-loader'], exclude: /node_modules/, include: /src/, } ], 是否都还记得呢，现在有现成的脚手架，很多人都很少自己去配置这些了，欸~当然还有相关的 sass/less等等预处理器loader这里就不一一介绍了。 babel-loader babel-loader 这个loader十分的重要，把高级语法转为ES5，常用于处理 ES6+ 并将其编译为 ES5。它允许我们在项目中使用最新的语言特性（甚至在提案中），而无需特别注意这些特性在不同平台上的兼容性。 介绍下主要的三个模块 babel-loader：使 Babel 与 Webpack 一起工作的模块 @babel/core：Babel核心模块。 @babel/preset-env：是Babel官方推荐的preseter，可以根据用户设置的目标环境，自动添加编译ES6+代码所需的插件和补丁 安装 npm install babel-loader @babel/core @babel/preset-env -D 配置 rules: [ { test: /\\.js$/, exclude: /node_modules/, //排除掉，不排除拖慢打包的速度 use: { loader: 'babel-loader', options: { cacheDirectory: true, // 启用缓存机制以防止在重新打包未更改的模块时进行二次编译 presets: [[ 'env', { modules: false, // 将ES6 Module的语法交给Webpack本身处理 } ]], }, }, } ], html-loader Webpack 可不认识 html，直接报错，需要loader转化 html-loader 用于将 HTML 文件转换为字符串并进行格式化，它允许我们通过 JS 加载一个 HTML 片段 安装 npm install html-loader -D 配置 rules: [ { test: /\\.html$/, use: 'html-loader', } ], // index.js import otherHtml from './other.html'; document.write(otherHtml); 这样你可以在js中加载另一个页面，写刀当前index.html里面 file-loader 用于打包文件类型的资源，比如对png、jpg、gif等图片资源使用file-loader，然后就可以在JS中加载图片了 安装 npm install file-loader -D 配置 const path = require('path'); module.exports = { entry: './index.js', output: { path: path.join(__dirname, 'dist'), filename: 'bundle.js', }, module: { rules: [ { test: /\\.(png|jpg|gif)$/, use: 'file-loader', } ], }, }； url-loader 既然介绍了 file-loader 就不得不介绍 url-loader，它们很相似，但是唯一的区别是用户可以设置文件大小阈值。大于阈值时返回与file-loader相同的publicPath，小于阈值时返回文件base64编码。 安装 npm install url-loader -D 配置 rules: [ { test: /\\.(png|jpg|gif)$/, use: { loader: 'url-loader', options: { limit: 1024, name: '[name].[ext]', publicPath: './assets/', }, }, } ], ts-loader TypeScript使用得越来越多，对于我们平时写代码有了更好的规范，项目更加利于维护...等等好处，我们也在Webpack中来配置loader,本质上类似于 babel-loader，是一个连接 Webpack 和 Typescript 的模块 安装 npm install ts-loader typescript loader配置，主要的配置还是在 tsconfig.json 中 rules: [ { test: /\\.ts$/, use: 'ts-loader', } ], vue-loader 用来处理vue组件,还要安装vue-template-compiler来编译Vue模板，估计大家大部分都用脚手架了 安装 npm install vue-loader vue-template-compiler -D rules: [ { test: /\\.vue$/, use: 'vue-loader', } ], 写一个简单的Loader 介绍了几个常见的loader的安装配置，我们在具体的业务的实现的时候，可能遇到各种需求，上面介绍的或者npm上都没有的加载器都不适合当前的业务场景，那我们可以自己去实现一个自己的loader来满足自己的需求，下面介绍一下如何自定义一个loader 初始化项目 初始化项目 先创建一个项目文件夹（名字可以随意，当然肯定是英文名）后进行初始化 npm init -y 安装依赖 安装依赖： Webpack 和 Webpack脚手架 和 热更新服务器 不同的版本 Webpack 可能有些差异，如果你跟着我的这个例子写的话，建议和我装一样的版本 npm install webpack@4.39.2 webpack-cli@3.3.6 webpack-dev-server@3.11.0 -D 新建一个index.html文件 dist/index.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 新建一个入口文件 index.js 文件 src/index.js document.write('hello world') 创建 webpack.config.js 配置文件 配置出口和入口文件 配置devServer服务 const path = require('path') module.exports = { entry: './src/index.js', output: { path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', }, devServer: { contentBase: './dist', overlay: { warnings: true, errors: true, }, open: true, }, } 在 package.json 中配置启动命令 &quot;scripts&quot;: { &quot;dev&quot;: &quot;Webpack-dev-server&quot; }, 启动 npm run dev devServer帮我们启动一个服务器，每次修改index.js不需要自己在去打包，而是自动帮我们完成这项任务 页面内容就是我们index.js编写的内容被打包成在dist/bundle.js引入到index.html了 当前目录结构 Webpack-demo ├── dist │ └── index.html ├── package-lock.json ├── package.json ├── src │ └── index.js └── Webpack.config.js 实现一个简单的 loader 在 src/MyLoader/my-loader.js module.exports = function (source) { // 在这里按照你的需求处理 source return source.replace('word', ', I am Xiaolang') } 返回其它结果 this.callback this.callback( // 当无法转换原内容时，给 Webpack 返回一个 Error err: Error | null, // 原内容转换后的内容 content: string | Buffer, // 用于把转换后的内容得出原内容的 Source Map，方便调试 sourceMap?: SourceMap, // 如果本次转换为原内容生成了 AST 语法树，可以把这个 AST 返回,以方便之后需要 AST 的 Loader 复用该 AST，以避免重复生成 AST，提升性能 abstractSyntaxTree?: AST ); 打开代码对应的source-map，方便调试源代码。source-map 可以方便实际开发者在浏览器控制台查看源代码。如果不处理source-map，最终将无法生成正确的map文件，在浏览器的开发工具中可能会看到混乱的源代码。 为了在使用 this.callback 返回内容时将 source-map 返回给 Webpack loader 必须返回 undefined 让 Webpack 知道 loader 返回的结果在 this.callback 中，而不是在 return module.exports = function(source) { // 通过 this.callback 告诉 Webpack 返回的结果 this.callback(null, source.replace('word', ', I am Xiaolang'), sourceMaps); return; }; 常用加载本地 loader 的两种方式 使用 path.resolve 指向这个本地文件 const path = require('path') module.exports = { module: { rules: [ { test: /\\.js$/, use: path.resolve('./src/myLoader/my-loader.js'), }, ], }, } 先去 node_modules 项目下寻找 my-loader，如果找不到，会再去 ./src/myLoader/ 目录下寻找 module.exports = { //... module: { rules: [ { test: /\\.js$/, use: ['my-loader'], }, ], }, resolveLoader: { modules: ['node_modules', './src/myLoader'], }, } 一个 loader的职责是单一的，使每个loader易维护。 如果源文件需要分多步转换才能正常使用，通过多个Loader进行转换。当调用多个loader进行文件转换时，每个loader都会链式执行。 第一个loader会得到要处理的原始内容，将前一个loader处理的结果传递给下一个。处理完毕，最终的Loader会将处理后的最终结果返回给 Webpack 所以，当你写loader记得保持它的职责单一，你只关心输入和输出。 option 参数 module: { rules: [ { test: /\\.js$/, use: [ { loader: 'my-loader', options: { flag: true, }, }, ], }, ], }, 那么我们如何在loader中获取这个写入配置信息呢？ Webpack 提供了loader-utils工具 在之前写的loader修改 const loaderUtils = require('loader-utils') module.exports = function (source) { // 获取到用户给当前 Loader 传入的 options const options = loaderUtils.getOptions(this) console.log('options--&gt;', options) // 在这里按照你的需求处理 source return source.replace('word', ', I am Xiaolang') } 控制台也打印了出来 4. 缓存 如果为每个构建重新执行重复的转换操作，这样Webpack构建可能会变得非常慢。 Webpack 默认会缓存所有loader的处理结果，也就是说，当待处理的文件或者依赖的文件没有变化时，不会再次调用对应的loader进行转换操作 module.exports = function (source) { // 开始缓存 this.cacheable &amp;&amp; this.cacheable(); // 在这里按照你的需求处理 source return source.replace('word', ', I am Xiaolang') } 一般默认开启缓存，如果不想Webpack这个loader进行缓存，也可以关闭缓存 module.exports = function (source) { // 关闭缓存 this.cacheable(false); // 在这里按照你的需求处理 source return source.replace('word', ', I am Xiaolang') } 同步和异步 在某些情况下，转换步骤只能异步完成。 例如，您需要发出网络请求以获取结果。如果使用同步方式，网络请求会阻塞整个构建，导致构建非常缓慢。 module.exports = function(source) { // 告诉 Webpack 本次转换是异步的，Loader 会在 callback 中回调结果 var callback = this.async() // someAsyncOperation 代表一些异步的方法 someAsyncOperation(source, function (err, result, sourceMaps, ast) { // 通过 callback 返回异步执行后的结果 callback(err, result, sourceMaps, ast) }) }; 处理二进制数据 默认情况下，Webpack 传递给 Loader 的原始内容是一个 UTF-8 格式编码的字符串。但是在某些场景下，加载器处理的不是文本文件，而是二进制文件 官网例子 通过 exports.raw 属性告诉 Webpack 该 Loader 是否需要二进制数据 module.exports = function(source) { // 在 exports.raw === true 时，Webpack 传给 Loader 的 source 是 Buffer 类型的 source instanceof Buffer === true; // Loader 返回的类型也可以是 Buffer 类型的 // 在 exports.raw !== true 时，Loader 也可以返回 Buffer 类型的结果 return source; }; // 通过 exports.raw 属性告诉 Webpack 该 Loader 是否需要二进制数据 module.exports.raw = true; 实现一个渲染markdown文档loader 安装依赖 md 转 html 的依赖，当然可以选择另外一个模块 marked 我这里使用的 markdown-it npm install markdown-it@12.0.6 -D 辅助工具 用来添加 div 和 class module.exports = function ModifyStructure(html) { // 把h3和h2开头的切成数组 const htmlList = html.replace(/&lt;h3/g, '$*(&lt;h3').replace(/&lt;h2/g, '$*(&lt;h2').split('$*(') // 给他们套上 .card 类名的 div return htmlList .map(item =&gt; { if (item.indexOf('&lt;h3') !== -1) { return `&lt;div class=&quot;card card-3&quot;&gt;${item}&lt;/div&gt;` } else if (item.indexOf('&lt;h2') !== -1) { return `&lt;div class=&quot;card card-2&quot;&gt;${item}&lt;/div&gt;` } return item }) .join('') } 新建一个loader /src/myLoader/md-loader.js const { getOptions } = require('loader-utils') const MarkdownIt = require('markdown-it') const beautify = require('./beautify') module.exports = function (source) { const options = getOptions(this) || {} const md = new MarkdownIt({ html: true, ...options, }) let html = beautify(md.render(source)) html = `module.exports = ${JSON.stringify(html)}` this.callback(null, html) } 这样loader也写完了，this.callback(null, html) 和 return 在这里差不多哈。 html = `module.exports = ${JSON.stringify(html)}` 这里解析的结果是一个 HTML 字符串。如果直接返回，也会面临Webpack无法解析模块的问题。正确的做法是把这个HTML字符串拼接成一段JS代码。 这时候我们要返回的代码就是通过module.exports导出这个HTML字符串，这样外界在导入模块的时候就可以接收到这个HTML字符串。 然后在webpack.config.js使用这个加载器 const path = require('path') module.exports = { entry: './src/index.js', output: { path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', }, module: { rules: [ { test: /\\.js$/, use: [ { loader: 'my-loader', options: { flag: true, }, }, ], }, { test: /\\.md$/, use: [ { loader: 'md-loader', }, ], }, ], }, resolveLoader: { modules: ['node_modules', './src/myLoader'], }, devServer: { contentBase: './dist', overlay: { warnings: true, errors: true, }, open: true, }, } 最后在index.js中加载一个md文件，我这里随便整个，新建github的readme.md document.write('hello word') import mdHtml from './test.md' const content = document.createElement('div') content.className = 'content' content.innerHTML = mdHtml document.body.appendChild(content) 目录结构 Webpack-demo ├── dist │ └── index.html ├── package-lock.json ├── package.json ├── src │ ├── index.js │ ├── myLoader │ │ ├── beautify.js │ │ ├── md-loader.js │ │ └── my-loader.js │ └── test.md └── webpack.config.js github仓库地址：https://github.com/LianTianNo1/webpack-loader-demo 结语 感谢大家能看到这里哈~ ，现在打包构建工具也慢慢增多了vue-cli，vite等等，但是 webpack 仍然有一席之地，很多值得学习的地方，继续努力学习~~ 原文地址：https://juejin.cn/post/7100534685134454815 ","link":"https://chenmi.online/blog/post/20220702/"},{"title":"如何在 HTML 中使用 Preload 和 Prefetch 来加载资源","content":"介绍 在页面上加载资源是实现 Web 最佳性能和无缝用户体验的重要方式。一般来说，网页会加载多个 CSS、字体、JavaScript 和图片文件。这些资源默认是渲染阻塞(render-blocking)，会降低加载性能。 在本文中，你将学到一个称为资源提示(resource hints)的新功能，例如 preload 和 prefetch 。使用这种方式可以克服渲染阻塞。 前提条件 本文基于 Google Chrome 版本 86.0.4240.80 构建 第一步：理解渲染阻塞 当对资源的请求处于渲染阻塞状态时，这意味着在该请求完成之前不会触发 window.onload 事件。在现代单页应用程序中，大多数资源（如 CSS 和 JavaScript 文件以及图像）都依赖此事件才能开始处理，这意味着在渲染阻塞请求完成加载之前，部分 UI 不会开始渲染或显示在屏幕上。 要查看实际效果，可以创建一个 HTML 文件： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href='https://fonts.googleapis.com/css?family=Roboto:400,600|Material+Icons'&gt; &lt;style&gt; p { font-family: Roboto; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; Hello &lt;/p&gt; &lt;script&gt; window.onload = function () { console.log('Loaded'); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在 Chrome 中打开这个 HTML 文件。接下来，打开开发人员工具并选择网络。选择慢速 3G 的连接，然后重新加载页面。 加载 CSS 文件后，控制台会立即记录 Loaded 消息，如下图所示： 在构建和加载大型网站时，CSS 和 JavaScript 以及其他资源可能需要很长时间才能加载完成。因此，CSS 样式可能不会立即显示。这时，选择预加载资源可以消除这种影响并阻止延迟加载。 第二步：预加载资源 为了阻止默认的渲染阻塞并确保字体和 CSS 等资源在页面生命周期的早期开始加载，此时就需要实现预加载。 rel=&quot;preload&quot; 用于预加载资源。它可以应用于多种文件格式，包括 CSS、JS、字体、图像等。根据预加载的文件类型，可能还需要包含相应的 as 属性以及 rel=&quot;preload&quot;。对于 CSS，as= 需要设置为 &quot;style&quot;。对于 JavaScript，as= 需要设置为 &quot;script&quot;。 修改上面的 HTML 文件的 &lt;link&gt;。设置 rel=&quot;preload&quot;。添加 as=&quot;style&quot;： &lt;head&gt; &lt;link rel=&quot;preload&quot; as=&quot;style&quot; href='https://fonts.googleapis.com/css?family=Roboto:400,600|Material+Icons'&gt; &lt;style&gt; html { font-family: Roboto; } &lt;/style&gt; &lt;/head&gt; 这时会看到在 CSS 请求开始之前显示了 Loaded 日志，如下图所示： 但是，你可能注意到 CSS 样式尚未应用于页面。那是因为使用 preload 或 prefetch 只会获取资源，但不会应用它。相反，预加载和预抓取会将资源保留在内存中。因此必须定义在什么时候加载资源。 由于 onload 解决方案依赖于 JavaScript，因此添加包含 &lt;link&gt; 标签的 &lt;noscript&gt; 标签，并设置 rel=&quot;stylesheet&quot;： &lt;link rel=&quot;preload&quot; as=&quot;style&quot; onload=&quot;this.rel = 'stylesheet'&quot; href='https://fonts.googleapis.com/css?family=Roboto:100,900|Material+Icons'&gt; &lt;noscript&gt; &lt;link rel=&quot;stylesheet&quot; href='https://fonts.googleapis.com/css?family=Roboto:400,600|Material+Icons'&gt; &lt;/noscript&gt; 这样可以确保在 JavaScript 被禁用或加载失败时显示字体。 第三步：预抓取资源 预抓取的原理和预加载类似。不同点在于，当预抓取资源时，浏览器认为该资源是低优先级的，这意味着资源将稍后加载。因此，预抓取通常是用来实现最初不需要但稍后使用的资源。 要实现 prefectching，设置 rel=&quot;prefetching&quot; ： &lt;link rel=&quot;prefetch&quot; as=&quot;style&quot; onload=&quot;this.rel = 'stylesheet'&quot; href='https://fonts.googleapis.com/css?family=Roboto:100,900|Material+Icons'&gt; 预抓取和预加载 CSS 有助于提高 Web 性能。 第四步：预加载 JavaScript 预加载 JavaScript 资源的方式有些不同。下面的例子取自关于预加载的谷歌开发者文章： &lt;link rel=&quot;preload&quot; href=&quot;used-later.js&quot; as=&quot;script&quot;&gt; &lt;!-- ... --&gt; &lt;script&gt; var usedLaterScript = document.createElement('script'); usedLaterScript.src = 'used-later.js'; document.body.appendChild(usedLaterScript); &lt;/script&gt; 这里重要的一步是设置标签的 src 属性并将其插入到 DOM 中。 原文地址：https://www.digitalocean.com/community/tutorials/html-preload-prefetch ","link":"https://chenmi.online/blog/post/20220629/"},{"title":"webpack -- 版本5配置","content":"下面是一个完整的webpack.config.js配置案例 /* 引入webpack及配置合并函数 */ const webpack = require(&quot;webpack&quot;); /* Webpack4 =&gt; Webpack5 */ // const merge = require(&quot;webpack-merge&quot;); const { merge } = require(&quot;webpack-merge&quot;); /* 引入本地输出路径 */ const path = require(&quot;path&quot;); const { srcPath, distPath, wwwPath } = require(&quot;./path&quot;); /* 引入通用配置对象（等待合并） */ const commonConf = require(&quot;./webpack.common.js&quot;); /* 引入各种功能插件 */ const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;); /* Webpack4 =&gt; Webpack5 */ // output : { clean: true } const { CleanWebpackPlugin } = require(&quot;clean-webpack-plugin&quot;); const TerserPlugin = require(&quot;terser-webpack-plugin&quot;); const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;); /* Webpack4 =&gt; Webpack5 */ // const OptimizeCssAssetsPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;); const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;); module.exports = { /* 输出模式 */ // mode: &quot;development&quot;, mode: &quot;production&quot;, /* 入口文件 每个入口文件对应着一棵依赖树 */ entry: { index: path.join(srcPath, &quot;js&quot;, &quot;index.js&quot;), other: path.join(srcPath, &quot;js&quot;, &quot;other.js&quot;), }, /* bundle输出位置 */ /* dev */ // output: { // filename: &quot;[name].[hash].js&quot;, // 打包代码时，加上 hash 戳 // path: distPath, // }, /* prod */ output: { filename: &quot;[name].[contenthash:8].js&quot;, // 打包代码时，加上 hash 戳 path: wwwPath, // 如果有CDN // publicPath: 'http://cdn.abc.com' // 异步chunk输出位置 chunkFilename: &quot;async/[id].js&quot;, }, /* 使用不同【loader+具体配置】去编译加载不同【源码模块】 */ module: { rules: [ /* common */ { // 找到所有的js文件 test: /\\.js$/, // 使用babel-loader做ES高级语法向ES5的转换 use: [&quot;babel-loader&quot;] /* 以下两个只需要写一个 */, // 查找范围仅限于src目录 include: srcPath, exclude: /node_modules/, }, // 开发环境下CSS的配置 { test: /\\.css$/, // loader 的执行顺序是：从后往前 /* postcss.config.js中的配置 module.exports = { plugins: [require(&quot;autoprefixer&quot;)], }; */ use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;postcss-loader&quot;], }, /* Webpack4 =&gt; Webpack5 */ /* 关于asset详见：https://webpack.docschina.org/guides/asset-modules/ */ // { // test: /\\.(png|jpg|jpeg|gif)$/, // use: [ // { // loader: &quot;file-loader&quot;, // options: {}, // }, // ], // }, { // 图片的转化 test: /\\.(jpe?g|png|gif|bmp)$/i, type: &quot;asset/resource&quot;, }, // scss开发环境 { test: /\\.scss$/, // 增加 'less-loader' ，注意顺序 use: [ &quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;, &quot;postcss-loader&quot;, ], }, /* prod */ /* Webpack4 =&gt; Webpack5 */ /* 关于asset详见：https://webpack.docschina.org/guides/asset-modules/ */ // { // test: /\\.(png|jpg|jpeg|gif)$/, // use: { // loader: &quot;url-loader&quot;, // options: { // // 小于 5kb 的图片用 base64 格式产出 // // 否则，依然延用 file-loader 的形式，产出 url 格式 // limit: 5 * 1024, // // 打包到 img 目录下 // outputPath: &quot;img/&quot;, // // 不一定以ESM模块形式去引入 // // 不要看到源代码中未以ESM模块形式去引入a.png 就给哥tree-shaking掉（html中可能以src形式引用） // esModule: false, // }, // }, // }, { // 图标的转化 test: /\\.(woff|woff2|eot|ttf|otf|svg)$/i, type: &quot;asset/resource&quot;, }, { // 图片的转化 test: /\\.(jpe?g|png|gif|bmp)$/i, // type: &quot;asset/resource&quot;, // type: &quot;asset/inline&quot;, // 自动切换resource与inline type: &quot;asset&quot;, parser: { dataUrlCondition: { maxSize: 8192, // 8kb }, }, }, // 生产环境下CSS配置 // 抽离 css { test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;postcss-loader&quot;, ], }, { test: /\\.scss$/, use: [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;sass-loader&quot;, &quot;postcss-loader&quot;, ], }, ], }, plugins: [ /* common */ new HtmlWebpackPlugin({ template: `html-withimg-loader!${path.join(srcPath, &quot;index.html&quot;)}`, filename: &quot;index.html&quot;, minify: { collapseWhitespace: true, keepClosingSlash: true, removeComments: true, removeRedundantAttributes: true, removeScriptTypeAttributes: true, removeStyleLinkTypeAttributes: true, useShortDoctype: true, }, chunks: [&quot;index&quot;, &quot;common&quot;], }), new HtmlWebpackPlugin({ template: `html-withimg-loader!${path.join( srcPath, &quot;views&quot;, &quot;other.html&quot; )}`, filename: &quot;other.html&quot;, minify: { collapseWhitespace: true, keepClosingSlash: true, removeComments: true, removeRedundantAttributes: true, removeScriptTypeAttributes: true, removeStyleLinkTypeAttributes: true, useShortDoctype: true, }, chunks: [&quot;other&quot;, &quot;common&quot;, &quot;vendor&quot;], }), /* dev */ new webpack.DefinePlugin({ // 相当于window.ENV = 'production' ENV: JSON.stringify(&quot;development&quot;), }), // 会默认清空 output.path 文件夹 new CleanWebpackPlugin(), /* prod */ // 抽离 css 文件 new MiniCssExtractPlugin({ filename: &quot;css/[name].[contenthash:8].css&quot;, }), new webpack.DefinePlugin({ ENV: JSON.stringify(&quot;production&quot;), }), new CleanWebpackPlugin(), ], /* dev */ devServer: { hot: true, // 热更新 port: 8000, // 测试服务器端口 open: true, // 自动打开浏览器 compress: true, // 启动 gzip 压缩 proxy: { &quot;/api&quot;: { target: &quot;http://localhost:9000/api&quot;, changeOrigin: true, ws: true, pathRewrite: { &quot;^/api&quot;: &quot;&quot;, }, }, }, }, /* prod */ optimization: { /* Webpack4 =&gt; Webpack5 */ // minimizer: [ // new TerserPlugin(), // new OptimizeCssAssetsPlugin({}) // ], usedExports: true, //只导出被使用的模块 minimize: true, // 启动压缩 concatenateModules: true, minimizer: [ new TerserPlugin(), // new OptimiazeCssAssetPlugin(), new CssMinimizerPlugin(), ], splitChunks: { // 同步异步都使用分包 chunks: &quot;all&quot;, cacheGroups: { // 第三方模块 vendor: { name: &quot;vendor&quot;, // chunk 名称 priority: 1, // 权限更高的优先抽离，重要！！！ test: /[\\\\/]node_modules[\\\\/]/, minSize: 0, // 大小限制 minChunks: 1, // 最少复用过几次 }, // 公共的模块 common: { name: &quot;common&quot;, // chunk 名称 test:/[\\\\/]src[\\\\/]utils[\\\\/]/ priority: 2, // 优先级 minSize: 0, // 公共模块的大小限制 minChunks: 1, // 公共模块最少复用过几次 }, }, }, }, }; ","link":"https://chenmi.online/blog/post/2022062202/"},{"title":"webpack -- 版本4配置","content":"下面是一个完整的webpack.config.js配置案例 /* 引入各种功能插件 */ const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;); const { CleanWebpackPlugin } = require(&quot;clean-webpack-plugin&quot;); const TerserPlugin = require(&quot;terser-webpack-plugin&quot;); const OptimizeCssAssetsPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;); const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;); module.exports = { /* 打包模式（生产模式下会自动开启Tree-Shaking） */ mode: &quot;development&quot;, // mode: &quot;production&quot;, /* 入口JS文件 每个入口文件对应着一棵依赖树 */ entry: { index: &quot;../src/js/index.js&quot;, other: &quot;../src/js/other.js&quot;, }, /* bundle输出位置 */ /* dev */ output: { // 根据js文件内容不同 生成不同的哈希(签名算法) 用于判断是否应该重新下载该文件 filename: &quot;[name].[hash8].js&quot;, // bundle输出文件夹 path: disPath, }, /* prod */ // output: { // filename: &quot;[name].[contenthash:8].js&quot;, // 打包代码时，加上 hash 戳 // path: wwwPath, // // 如果有CDN // // publicPath: 'http://cdn.abc.com' // // 异步chunk输出位置 以流水号命名 // chunkFilename: &quot;async/[id].js&quot;, // }, /* 使用不同【loader+具体配置】去编译加载不同【源码模块】 */ module: { rules: [ /* common */ /* 编译加载JS模块 */ { // 找到所有的js文件 test: /\\.js$/, // 使用babel-loader做ES高级语法向ES5的转换 use: [&quot;babel-loader&quot;] /* 以下两个只需要写一个 */, // 查找范围仅限于src目录 include: &quot;../src&quot;, // 不查找node_modules目录 exclude: /node_modules/, }, /* dev */ /* 编译加载图片模块 */ // { // test: /\\.(png|jpg|jpeg|gif)$/, // use: [ // { // loader: &quot;file-loader&quot;, // options: {}, // }, // ], // }, // 开发环境下CSS的配置 /* 编译加载CSS模块 */ // { // test: /\\.css$/, // // loader 的执行顺序是：从后往前 // /* // postcss.config.js中的配置 // module.exports = { // plugins: [require(&quot;autoprefixer&quot;)], // }; // */ // use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;postcss-loader&quot;], // }, // scss开发环境 /* 编译加载SCSS模块 */ // { // test: /\\.scss$/, // 增加 'less-loader' ，注意顺序 // use: [ // &quot;style-loader&quot;, // &quot;css-loader&quot;, // &quot;sass-loader&quot;, // &quot;postcss-loader&quot;, // ], // }, /* prod */ /* 编译加载图片模块 */ // 考虑 base64 编码的情况 { test: /\\.(png|jpg|jpeg|gif)$/, use: { loader: &quot;url-loader&quot;, options: { // 小于 5kb 的图片用 base64 格式产出 // 否则，依然延用 file-loader 的形式，产出 url 格式 limit: 1 * 1024, // 输出到bundle根目录下的img文件夹 outputPath: &quot;img/&quot;, // 不一定以ESM模块形式去引入 // 不要看到源代码中未以ESM模块形式去引入a.png 就给哥tree-shaking掉（html中可能以src形式引用） esModule: false, }, }, }, /* 编译加载CSS模块 */ // 抽离css { test: /\\.css$/, use: [ // 将样式统一提取到独立的CSS文件 MiniCssExtractPlugin.loader, // 加载CSS文件 &quot;css-loader&quot;, // 先对C3的样式定义加必要的浏览器兼容前缀 &quot;postcss-loader&quot;, ], }, /* 编译加载SCSS模块 */ { test: /\\.scss$/, use: [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, // 将SCSS编译为CSS &quot;sass-loader&quot;, &quot;postcss-loader&quot;, ], }, ], }, plugins: [ /* common */ /* 为html文件注入自动识别hash后缀的能力 */ new HtmlWebpackPlugin({ // 令html识别原始的&lt;img src=&quot;xxx&quot;/&gt; template: `html-withimg-loader!${path.join(srcPath, &quot;index.html&quot;)}`, filename: &quot;index.html&quot;, // 压缩选项 minify: { collapseWhitespace: true, keepClosingSlash: true, removeComments: true, removeRedundantAttributes: true, removeScriptTypeAttributes: true, removeStyleLinkTypeAttributes: true, useShortDoctype: true, }, // 需要依赖的具体chunk chunks: [&quot;index&quot;, &quot;common&quot;], }), new HtmlWebpackPlugin({ template: `html-withimg-loader!${path.join(srcPath, &quot;views&quot;, &quot;other.html&quot;)}`, filename: &quot;other.html&quot;, minify: { collapseWhitespace: true, keepClosingSlash: true, removeComments: true, removeRedundantAttributes: true, removeScriptTypeAttributes: true, removeStyleLinkTypeAttributes: true, useShortDoctype: true, }, chunks: [&quot;other&quot;, &quot;common&quot;, &quot;vendor&quot;], }), /* dev */ /* 定义全局变量 */ new webpack.DefinePlugin({ // 相当于定义全局变量const ENV = 'production' ENV: JSON.stringify(&quot;development&quot;), }), // 会默认清空 output.path 文件夹 new CleanWebpackPlugin(), /* prod */ // 抽离css文件到css目录下 new MiniCssExtractPlugin({ filename: &quot;css/[name].[contenthash:8].css&quot;, }), new webpack.DefinePlugin({ ENV: JSON.stringify(&quot;production&quot;), }), ], /* dev */ /* 开发服务器（生产环境下使用Nginx） 1. 跨域代理 2. 模块热更新（hot modudle replacement） */ devServer: { hot: true, // 热更新 port: 8000, // 测试服务器端口 open: true, // 自动打开浏览器 compress: true, // 启动 gzip 压缩 /* 跨域代理 */ proxy: { &quot;/api&quot;: { target: &quot;http://localhost:9000/api&quot;, changeOrigin: true, // webpack-dev-server通过websocket协议与浏览器的内核服务器保持长连接 ws: true, // 覆盖/api为卵都没有 pathRewrite: { &quot;^/api&quot;: &quot;&quot;, }, }, }, }, /* prod */ /* 性能优化选项 */ optimization: { /* 压缩JS与CSS */ minimizer: [ new TerserPlugin(), new OptimizeCssAssetsPlugin({}) ], /* 分包配置 */ splitChunks: { // 同步异步都使用分包 // initial 只考虑同步引入 import xxx from &quot;path&quot; // async 只考虑异步引入 const About = import(path) // all 同步异步都考虑 chunks: &quot;all&quot;, /* 拆包配置 */ cacheGroups: { // 第三方模块统一拆到vender.js中 vendor: { name: &quot;vendor&quot;, // chunk 名称 priority: 1, // 权限更高的优先抽离，重要！！！ test: /node_modules/, minSize: 0, // 大小限制 minChunks: 1, // 最少复用过几次 }, // utils下的轮子统一拆到common.js中 common: { name: &quot;common&quot;, // chunk 名称 priority: 0, // 优先级 test: /src\\/utils/, minSize: 0, // 公共模块的大小限制 minChunks: 1, // 公共模块最少复用过几次 }, }, }, }, }; ","link":"https://chenmi.online/blog/post/2022062201/"},{"title":"webpack -- 初识","content":"webpack定义：前端工程的打包构建工具 打包原理 今日之前端工程都是模块化的，A引用B,B又引用CD,CD又分别引用DEF和HIJ，最后形成一棵庞大的依赖树 Webpack从入口文件开始顺藤摸瓜，将一整棵依赖树都连根拔起，然后逐节点地编译处理为浏览器能直接识别的代码，并按执行顺序汇总打包到一个JS文件中（当然也可以根据具体不同配置进行分包） 说说何为module、何为chunk、何为bundle？ module即源代码模块。可以是JS/TS/dts/JSX，CSS/SASS/LESS/STYLUS,Vue，各种图片文件，json/xml等数据文件，等等 bundle是最终输出的包，你会发现源代码模块一大堆，最终输出的包通常就寥寥几个JS文件和CSS文件，外加那么一两个静态资源文件夹 chunk翻译过来叫块，从源码模块到最终包的打包过程中，你可以自由地将不同模块做整合与拆分，形成的就是块 bundle指的是产出包的整体，chunk是bundle的组成部分 为什么要拆分重组呢？ 为了最大化复用；例如组件库、Vue/React框架、常用的轮子、node_modules里的东西，更新频率极低，组织在一起就没必要每次升级时都重新下载 为了提升性能；例如业务代码，更新频率非常高，组织为一个chunk，其体积通常较小（你能写出1M文字出来吗），每次升级时重新下载这一点点东西即可，性能高 ","link":"https://chenmi.online/blog/post/20220622/"},{"title":"【Linux系统管理】文件管理","content":"系统须知 # ip a //查看IP # ifup ens33 //启动网卡，临时获取一个IP 快捷键操作 tab键 //补全命令或者补全文件路径 ctrl + c //结束命令 ctrl + l //清屏 ctrl + a //定义命令的光标到首行 命令写法 命令 【空格】选项 【空格】 文件/目录 //选项可有可无，但是选项不同，命令的功能也不同 命令帮助： --help man //按q退出 # touch --help # man touch 目录结构 Windows： 多根方式 C: D: Linux: 单根 / bin 存放命令 - 普通用户的命令 boot linux启动内核文件 dev 存放设备 etc 存放系统配置文件 home 存放普通用户的家目录 root 超级管理员root的家 sbin 存放命令 - 管理员用户的命令 tmp 临时目录 var 动态信息，内存，进程 绝对路径： 以根 / 开始 相对路径： 相对当前目录开始 怎么去切换目录： # cd //切换目录 . //当前目录 .. //上一级目录 练习： 切换目录操作 # mkdir -p /{a/e/f/g,b/{h,j},c} 1、请使用绝对路径切换到目录g cd /a/e/f/g 2、请使用相对路径切换到a cd ../../.. 3、请使用绝对路径切换到c cd /c 4、请使用相对路径切换到b cd ../b 5、请使用相对路径切换到h cd ./h ~ cd h # yum install tree -y //安装tree命令 # tree /a /b /c /a └── e └── f └── g /b ├── h └── j /c 5 directories, 0 files 文件管理 文件增删改查 增： touch //创建文件 # touch a.txt 删： rm //删除 -r //删除目录 -f //强制删除，非交互 # rm -rf a.txt 改： mv //移动和改名 cp //复制 vi/vim //编辑文件内容 # touch a.txt # mv a.txt b.txt //把a.txt改名为b.txt # mv b.txt /tmp/ //把b.txt移动到/tmp目录下 # cp a.txt b.txt //复制a.txt为b.txt 查： cat //查看所有内容 -n //加上行号 head //默认是查看文件的前10行 tail //默认是查看文件的后10行 目录增删改查 增： mkdir //创建目录 -p //创建联级目录 -v //显示创建过程 删： rm //删除 -r //删除目录一定要加上该选项 改： mv //移动和改名 cp //复制 -r //复制目录一定要加上-r的选项 查： ls //列出目录有哪些内容 -l //以长格式显示 -a //显示隐藏文件 -d //配合-l 去查看目录本身信息以长格式显示 # ls -l 等于 ll （开头第一个符号的含义） d 目录 - 文件 l 链接文件 b 设备文件 vi/vim编辑器 # yum install vim -y //最小化系统，默认没有vim命令 三种模式 命令模式--编辑模式--尾行模式 命令模式： 1、光标定位 0 //光标定位到该行的行首 $ //光标定位到该行的行尾 gg //光标定位到第一行的行首 G //光标定位到最后一行的行首 5gg ~ 5G //把光标定位到第5行的行首 2、内容处理（以行为单位） yy //复制光标所在行 2yy //复制2行，包括光标所在行 p //粘贴，粘贴到光标所在的下一行 dd //删除，删除光标所在行 3dd //删除3行，包含光标所在行往下 u //撤销 ctrl + r //反撤销 3、高亮关键字 /关键字 按n往下翻，按N往上翻 编辑模式： 按i进入编辑模式 - 从光标的前面开始插入内容 按a进入编辑模式 - 从光标的后面开始插入内容 按o进入编辑模式 - 另起一行开始插入 尾行模式： :wq //保存退出 :x shift+zz :q //不保存退出 加上 ！ 代表强制 1、替换修改内容 :1 s/root/ROOT/g //替换第一行里面所有的root为 ROOT :1,5 s/root/ROOT/ //替换1到5行里面出来的第一个root为ROOT :% s/root/ROOT/g //替换所有行里面出现所有root为ROOT (匹配的内容支持正则匹配) :% s/[0-9]//g //删除所有行里面的数字，替换为空=删除 2、功能 : set number //添加行号 : set list //列出所有字符 可视块模式： 批量添加： ctrl + v -&gt; 方向键选中块 -&gt; 大写的i （shift + i） -&gt; 输入添加的内容 -&gt; Esc Esc键 批量删除： ctrl + v -&gt; 方向键选中块 -&gt; d 或者 x 进行删除 shift + v //可视行 v //可视 （不规则） ","link":"https://chenmi.online/blog/post/20220621/"},{"title":"假如手机锁屏密码忘记了怎么办？","content":"今天(2022-06-20)发生了一件很不可思议的事情，我的vivo手机锁屏密码忘记了，还好我还记得vivo账号，在官网上找到解决办法：备份资料，重置手机。这样感觉确实达到想要的效果，但是没法备份的资料也就丢失了，这点很让我疑惑，为什么手机锁屏密码忘记了会这么麻烦。 下面是vivo对手机锁屏密码的说明： 基于消费者的隐私和信息安全，锁屏密码需要通过消费者手动设置确认并经过加密算法存储在手机本地， 手机不具备自动设置密码或修改密码的功能，vivo/iQOO也不具备获取手机锁屏密码的方式，锁屏密码 一旦忘记，将无法解锁手机并找回手机内的数据。 也就是说，密码忘了只能重置手机，再加上备份也只能部分备份。因此，不管怎样恢复（自己还是去服务中心），备份的资料只能尽可能挽救损失，丢了就是丢了。为什么不给用户多一个选择：既可以资料不丢失，又可以重置密码。 据我了解，目前还做不到。唯一的解决办法就是找个其他设备记录一下，以免忘记。。。 ","link":"https://chenmi.online/blog/post/20220620/"},{"title":"git push 常见用法","content":"git push的一般形式为 git push &lt;远程主机名&gt; &lt;本地分支名&gt; &lt;远程分支名&gt; ，例如 git push origin master：refs/for/master，即将本地的master分支推送到远程主机origin上的对应master分支， origin 是远程主机名。第一个master是本地分支名，第二个master是远程分支名。 git push origin master 如果远程分支被省略，如上则表示将本地分支推送到与之存在追踪关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建 git push origin ：refs/for/master 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于 git push origin --delete master git push origin 如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可以省略，将当前分支推送到origin主机的对应分支 git push 如果当前分支只有一个远程分支，那么主机名都可以省略，形如 git push，可以使用git branch -r ，查看远程的分支名 git push 的其他命令 这几个常见的用法已足以满足我们日常开发的使用了，还有几个扩展的用法，如下： git push -u origin master 如果当前分支与多个主机存在追踪关系，则可以使用 -u 参数指定一个默认主机，这样后面就可以不加任何参数使用git push，不带任何参数的git push，默认只推送当前分支，这叫做simple方式，还有一种matching方式，会推送所有有对应的远程分支的本地分支， Git 2.0之前默认使用matching，现在改为simple方式，如果想更改设置，可以使用git config命令。git config --global push.default matching OR git config --global push.default simple；可以使用git config -l 查看配置 git push --all origin 当遇到这种情况就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要 -all 选项 git push --force origin git push 的时候需要本地先git pull更新到跟服务器版本一致，如果本地版本库比远程服务器上的低，那么一般会提示你git pull更新，如果一定要提交，那么可以使用这个命令。 git push origin --tags //git push 的时候不会推送分支，如果一定要推送标签的话那么可以使用这个命令 关于 refs/for // refs/for 的意义在于我们提交代码到服务器之后是需要经过code review 之后才能进行merge的，而refs/heads 不需要 原文地址：https://www.cnblogs.com/qianqiannian/p/6008140.html ","link":"https://chenmi.online/blog/post/20220617/"},{"title":"reflow(回流)和repaint(重绘)","content":"简要：整个在浏览器的渲染过程中（页面初始化，用户行为改变界面样式，动画改变界面样式等）reflow(回流)和repaint(重绘) 会大大影响web性能，尤其是手机页面。因此我们在页面设计的时候要尽量减少reflow和repaint。 什么是reflow和repaint reflow：例如某个子元素样式发生改变，直接影响到了其父元素以及往上追溯很多祖先元素（包括兄弟元素），这个时候浏览器要重新去渲染这个子元素相关联的所有元素的过程称为回流。 reflow：几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。 repaint：如果只是改变某个元素的背景色、文 字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器 repaint（重绘）。repaint 的速度明显快于 reflow 下面情况会导致reflow发生 1：改变窗口大小 2：改变文字大小 3：内容的改变，如用户在输入框中敲字 4：激活伪类，如:hover 5：操作class属性 6：脚本操作DOM 7：计算offsetWidth和offsetHeight 8：设置style属性 转载地址：http://www.cnblogs.com/Peng2014/p/4687218.html ","link":"https://chenmi.online/blog/post/20220616/"},{"title":"浅析 async/await 异步函数","content":"async/await 异步函数可以将异步行为变成同步执行，并返回一个promise async function asyncFunction () { const value = await Promise.resolve(2); console.log('value:', value); // value: 2 try { // 错误的 promise 会抛出异常，需要 try...catch 捕获 const value = await Promise.reject(3); } catch (reason) { console.log('reason:', reason); // reason: 3 } // 没有返回值，默认是解决状态，值为 undefined } &lt;!-- more --&gt; setTimeout(console.log, 0, asyncFunction()) // Promise { &lt;state&gt;: &quot;fulfilled&quot;, &lt;value&gt;: undefined } 任务队列分为：（同步）主任务队列，（异步）微任务队列，宏任务队列 js解析到 await 关键词时，该行代码会被执行，同时 await 后面的代码( await 所在的作用域)会异步执行（暂存在微任务队列）： // 生成器 和 期约 的语法糖 async function parseValue () { // 同步执行时，await 后面的代码执行完（promise包装）并存入微任务队列， // 等当前微任务执行时，value才会赋值 const value = await 2; console.log(value); } parseValue(); setTimeout(console.log, 0, 3); // 宏任务队列最后执行 console.log(1); // 1 // 2 // 3 使用 Promise 实现的异步函数和 async/await 基本没啥区别，只不过书写方式不一样。说区别的话，那么使用 async/await 性能更优： function exector (resolve, reject) { setTimeout(reject, 0, 'error'); } function promiseFuntion () { new Promise(exector); } async function asyncFuntion () { await new Promise(exector) } promiseFuntion () // Uncaught (in promise) error // setTimeout（异步） // exector // promiseFuntion //（匿名） asyncFuntion () // Uncaught (in promise) error // asyncFuntion // await in asyncFuntion（异步） //（匿名） 解释： js引擎会在创建期约时尽可能保留完整的调用栈。在抛出错误时， 调用栈可以由运行时的错误处理逻辑获取，因而就会出现在栈追踪信息中。这意味着栈追踪信息会占用内存，从而带来一些计算和存储成本。 使用 async/await 时，exector()已经返回，所以它不在错误信息中。但 asyncFuntion() 此时被挂起，并没有退出。js 运行时可以简单地在嵌套函数中存储指向包含函数的指针，就跟对待同步函数调用栈一样。这个指针实际上存储在内存中，可用于在出错时生成栈追踪信息。这样就不会像之前那样带来额外的消耗。 ","link":"https://chenmi.online/blog/post/qian-xi-asyncawait-yi-bu-han-shu/"},{"title":"JavaScript 动画","content":"使用javascript也可以实现css动画的效果，涉及到函数requestAnimationFrame()，接收的参数是重绘前调用的函数，这个函数会接受一个DOMHighResTimeStamp实例(比如performance.now()的返回值)，以此为基础的动画函数如下： /** * js动画函数 * * timing:动画曲线函数 * draw:动画绘制函数 * duration:动画时间 */ function animation({ timing, draw, duration }) { //动画开始时间 let start = performance.now(); requestAnimationFrame(function animate(time) { // timeFraction: [ 0, 1 ] let timeFraction = (time - start) / duration; if (timeFraction &gt; 1) timeFraction = 1; // 计算当前动画状态 progress: [ 0, 1 ] let progress = timing(timeFraction) draw(progress); // 绘制函数 if (timeFraction &lt; 1) { requestAnimationFrame(animate); } }); } 设置函数timing可以实现ease、linear、ease-in等动画曲线，当然还可以自定义一些比较炫酷的曲线。 下面使用该函数在codepen上演示一下 代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;demo&lt;/title&gt; &lt;style&gt; body { margin: 0; padding: 0; width: 100%; height: 100vh; } .box { width: 100px; height: 100px; background-color: #000; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; var box = document.getElementsByClassName('box')[0]; animation({ duration: 2000, timing: function (timeFraction) { return timeFraction; }, draw: function (progress) { box.style.setProperty('transform', `translate(${150 * progress}%, 0%)`); } }); function animation({ timing, draw, duration }) { let start = performance.now(); requestAnimationFrame(function animate(time) { let timeFraction = (time - start) / duration; if (timeFraction &gt; 1) timeFraction = 1; let progress = timing(timeFraction) draw(progress); if (timeFraction &lt; 1) { requestAnimationFrame(animate); } }); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ","link":"https://chenmi.online/blog/post/20220107/"},{"title":"【笔记】UML概念模型","content":"UML概念模型主要包括基本构造块、运用于构造块的通用机制和用于组织UML视图的架构 构造块 构造块是UML的基本建模元素，是UML中用于表达的语言元素，是来自现实世界中概念的抽象描述方法。包括事物、关系和图。事物是对模型中关键元素的抽象体现；关系是事物和事物之间的联系方式；图是相关事物及其关系的聚合表现。 事物 事物包含构建事物，行为事物，分组事物，注释事物 构建事物：UML模型的静态部分，描述概念或者物理元素；包含以下 类class：具有相同属性、相同操作、相同关系、相同语义的一组对象描述 接口interface：描述元素的外部可见行为，即服务集合的定义说明 协作collaboration：多个元素共同工作、相互配合达到某个目的的交互动作 用例use case：一组动作序列的集合，动作序列特定的参与者触发或执行，结果可以反馈给参与者或者作为参数 组件component：系统中封装好的模块化部件（类似java中jar包），仅将外部接口暴露出来，内部实现隐藏 节点node：运行时存在的物理元素 行为事物：UML模型图的动态部分，描述静态元素之间产生的空间和时间的行为动作，类似于句子中的动词 交互：实现某功能的一组构建事物（元素）之间消息的集合，涉及消息，动作序列，连接 状态机：描述事物或交互在生命周期内相应事件所经历的状态序列 活动：描述一个操作执行时的过程信息 分组事物： UML模型图的组织部分，描述事物的组织结构包：把元素组织成组的机制 注释事物： UML模型的解释部分，用来对模型中的元素进行说明，解释 关系 关系是事物之间具体化的语义连接，在UML中有四种基本关系 关联 association 描述不同类元的实例之间的连接。一种对象和另一种对象存在联系，即“从一个对象可以访问到另一个对象”，例如：人和身份证 依赖dependency 描述一对模型元素之间的内在联系(语义关系[1])。一个元素的某些特性随着另一个独立的元素的特性变化而改变，例如：人和自行车 泛化generalization 类似于面向对象方法中的继承关系，即一个具体类对另一个具体类的继承，例如：宝马类泛化了小汽车类 实现realization 一种类与接口的关系，表示类是接口所有特征和行为的实现 图 根据UML图的基本功能和作用，包含以下 结构图：捕获事物与事物的之间的静态关系，用来描述系统的静态结构模型 行为图：捕获事物交互过程如何产生系统行为，用来描述系统的动态行为模型 UML2规范包含了：类图、对象图、组合结构图、组件图、部署图、包图、外廓图、用例图、活动图、状态机图、顺序图、通信图、时序图、交互概览图（后期笔记会进行整理） UML通用机制 通用机制描述了面向对象建模目的4种策略，并在UML不同的语境下被反复使用，使得UML更简单并易于使用 规格说明specifications 构造块的语法和语义的描述 修饰adornments 对规格说明的文字或图形的表示 通用划分common divisions 类型-实例：通用描述与某个特定的元素的对应，例如：类和对象 接口-实现：接口和实现它的类或组件、用例与实现它的协作、操作与实现它的方法等 UML扩展机制extensibility mechanisms 本身的描述能力可能不够，需要扩充某些细节上描述。在不改变整体语言风格的基础上定义一些通用性的扩展 构造型 构造型扩展了UML的词汇，可以用来创造新的构造块，这个新构造块是从现有的构造块派生的，但是针对特定的问题。 在图形上，把构造型表示成用双尖括号(&lt;&lt;&gt;&gt;)括起来的名字，放在其他元素名之上。 标记值 标记值扩展了构造型的特性，可以用来创建构造型规约的新信息。 如上图所示，authored是基于类扩展而来的构造型，用来表述事件队列；针对authored构造型有一个注释，注释中的version和author并不是UML的基本概念，而是新扩展的标记值，用来说明构造型的特殊信息。 约束 约束是对UML规则的扩展，或者是对已有规则的修改，使用{}中的文本串表示。 “4+1”架构 采用用例驱动，在软件生命周期的各个阶段对软件进行建模，从不同视角对系统进行解读，从而形成统一软件过程架构描述 组成：逻辑视图（类图）、开发视图（组件图）、进程视图（顺序图、协作图、状态机图）、物理进程（部署图）和场景视图（用例图） 逻辑视图：用于描述系统的功能需求，即系统给用户提供哪些服务；以及描述系统软件功能拆解后的组件关系、组件约束和边界，反映系统整体组成与系统如何构建的过程。在UML中由类图来表示 开发视图：开发视图关注软件开发环境下实际模块的组织，反映系统开发实施过程。 一个设计良好的开发视图，应该能够满足以下要求： 通过逻辑架构元素，能够找到它所有代码和所有的二进制交付件 每一个代码源文件，都能够找到它所属的逻辑架构元素 每一个二进制交付件，都能够找到它集成了哪些逻辑架构元素 进程视图：用于描述系统软件组件之间的通信时序，数据的输入输出。在UML中通常由时序图和流程图表示 物理视图：开发出的软件系统，最终是要运行在物理或软件环境上。物理环境可能是服务器、PC机、移动终端等物理设备；软件环境可以是虚拟机、容器、进程或线程。部署视图就是对这个部署信息进行描述。在UML中通常由部署图表示 场景视图：场景视图，即4+1中的1，4+1中的4个视图都是围绕着场景视图为核心的。它用于描述系统的参与者与功能用例间的关系，反映系统的最终需求和交互设计 软件架构设计流程：场景视图（架构师与客户）=〉逻辑视图（架构师与开发人员）=〉进程视图、开发视图、物理视图（开发小组） 语义关系，指语言单位之间在意义上的关系，主要表现为纵的方向上的聚合关系和横的方向上的组合关系，以及逻辑关系。语义的聚合关系指根据语言单位之间在意义上的对比而确立的可替代的垂直关系，包括同义关系、反义关系、类义关系、异义关系等；语义的组合关系指语言单位在语言体系中和语流中相互搭配构成的关系，包括施受关系、领属关系、限定关系、并列关系、支配关系、判断关系、说明补充关系等；语义的聚合关系和组合关系都是建立在逻辑关系的基础上的。语义的逻辑关系还有预设关系、蕴涵关系等。 ↩︎ ","link":"https://chenmi.online/blog/post/20210929/"},{"title":"【笔记】css过渡(transition)","content":"简写属性 transition =[[none|&lt;transition-property&gt;] || &lt;time&gt; || &lt;transition-timing-function&gt; || &lt;time&gt;] 初始值：all 0s ease 0s 第一个值指定哪些属性采用过渡，第二个值指定过渡时间，第三个指定过渡函数，第四个指定过渡延迟 使用过渡，最少要给过渡时间值，其他的会采用默认值 要给多个属性采用过渡，那么可以采用逗号分隔 关于过渡和反向过渡 过渡属性直接应用于元素上，那么进入和退出悬停状态都会有过渡效果，退出时是反向过渡；如果应用于元素目标状态，进入有过渡状态而退出没有效果 过渡中断，不同的浏览器会采用不同的策略，体现在反向过渡时采取的过渡时间和过渡延迟 在chrome，safari，opera中会采取原过渡时间，其中chrome和opera还会采用过渡延迟 而firefox和edge采用已过渡的时长作为反向过渡时间 transition-property 支持过渡的属性：CSS3 transition-property使用参考指南 过渡多个属性采用逗号分隔 撤销过渡效果可以使用none值，这样会禁用所有属性的过渡效果 transition-duration 单位可以是s或者ms 采用负值将没有过渡效果，不会影响其他属性的过渡 transition-timing-function 过渡函数记一些常用的，比如ease 、linear、step 可以在线自定义一些过渡函数：cubic-bezier.com 采用一些网站做好的函数：easings.net step效果跟阶梯一样，效果如下图，step(n,start) | step(n,end)| step-start | step-end transition-delay 从属性的值开始变化那一刻到过渡动画开始执行的时间间隔 采用负值且绝对值小于过渡时间，属性瞬间到达 |过渡延迟|/过渡时间 的位置然后开始过渡，此时的过渡时间为过渡时间+过渡延迟 采用负值且绝对值大于等于过渡时间，那么相当于没有过渡延迟 ","link":"https://chenmi.online/blog/post/20210925/"},{"title":"五类字体serif，sans-serif，monospace，cursive和fantasy","content":"一.示例 generic-font-families P.S.更多英文字体示例见参考资料-五种一般字体族英文示例 P.S.更多中文字体示例见参考资料-The Complete Beginner’s Guide to Chinese Fonts 二.作用 Generic font families are a fallback mechanism, a means of preserving some of the style sheet author’s intent in the worst case when none of the specified fonts can be selected. （摘自15.3.1 Generic font families） 由于不是所有字体在所有终端设备上都可用（有几千种字体，而且大部分都不是免费的），CSS提供了一种fallback机制：先列出想要的字体，再列出作为替补的字体，最后以一般字体族结尾 在最坏的情况下（指定的所有字体都不可用时），能通过这种方式保留一些样式表编写者的意图 一般字体族共有5个：serif，sans-serif，monospace，cursive和fantasy，相对常用的是前3个（衬线，无衬线和等宽字体族） 三.特点 serif 衬线字体族 特点： 具有修饰过的笔画，向外展开的或者尖细的末端，或者是带有实际衬线的末端 一笔一划末端（两头）都带点变化装饰，比如宋体笔画末端有毛笔字的感觉 文字末端有差异，在小字号下仍然容易辨认。但在大字号下笔画装饰部分可能会显得模糊或带有锯齿 示例： Times New Roman、MS Georgia 宋体、仿宋 衍生： petit-serif 小衬线字体族 末端变化不明显，可以当做无衬线 slab-serif 雕版衬线字体族 末端变化非常明显 sans-serif 无衬线字体族 sans-前缀是法语，发音为/san/，意为“无” 特点： 具有笔画清晰的末端–带有一点或者没有向外展开的，交错笔画，或者其它装饰 与“衬线字体”相比，如果字号比较小，看起来就会有些难以分辨，尤其段落阅读时容易串行 示例： MS Trebuchet、MS Arial、MS Verdana 黑体、幼圆、隶书、楷体 cursive 手写字体族 特点： 像手写的一样 示例： Caflisch Script、Adobe Poetica 徐静蕾手写体、迷你简黄草、华文行草、少女体 fantasy 梦幻字体族 特点： 艺术字，主要用于图片，页面上用的少 示例： WingDings、WingDings 2、WingDings 3、Symbol 萝卜体 monospace 等宽字体族 特点： 每个字形都等宽，主要用于英文，中文方块字本来就等宽 示例： Courier、MS Courier New、Prestige 大多数中文字体 四.使用原则 常识： 一个页面上不要用3，4种甚至更多字体 如非必要，不要在句中改变字体 sans-serif用于在线媒体，serif用于打印设备 monospace用于打字机和代码 小字号场景不要用sans-serif，衬线字体更容易辨认 最佳实践： sans-serif是页面首选，无衬线 因为在屏幕显示设备上，衬线会让文字变得难以辨认 serif不适合在线阅读，但打印效果很好，适用于页面打印版 衬线字体在打印的场景更容易阅读，让人更容易清楚区分不同字母。打印机对分辨率的要求更精细（355ppi），高分辨率下细节显示得很清楚，而不会像屏幕显示一样出现模糊 monospace用作代码示例 每个字符等宽，在页面上占据相同的空间，打字机就用这种字体 正文不要用fantasy和cursive 可以用在图片或者标题栏里 写在最后 PPT不要用宋体，不是瞎说的 转载原地址：https://www.cnblogs.com/shangsi/articles/12212792.html ","link":"https://chenmi.online/blog/post/20210914001/"},{"title":"轻松理解JS中的面向对象，顺便搞懂prototype和__proto__","content":"这篇文章主要讲一下JS中面向对象以及 __proto__，ptototype和constructor，这几个概念都是相关的，所以一起讲了。 在讲这个之前我们先来说说类，了解面向对象的朋友应该都知道，如果我要定义一个通用的类型我可以使用类(class)。比如在java中我们可以这样定义一个类： public class Puppy{ int puppyAge; public Puppy(age){ puppyAge = age; } public void say() { System.out.println(&quot;汪汪汪&quot;); } } 上述代码我们定义了一个Puppy类，这个类有一个属性是puppyAge，也就是小狗的年龄，然后有一个构造函数Puppy()，这个构造函数接收一个参数，可以设置小狗的年龄，另外还有一个说话的函数say。这是一个通用的类，当我们需要一个两岁的小狗实例是直接这样写，这个实例同时具有父类的方法: Puppy myPuppy = new Puppy( 2 ); myPuppy.say(); // 汪汪汪 但是早期的JS没有class关键字啊（以下说JS没有class关键字都是指ES6之前的JS，主要帮助大家理解概念），JS为了支持面向对象，使用了一种比较曲折的方式，这也是导致大家迷惑的地方，其实我们将这种方式跟一般的面向对象类比起来就很清晰了。下面我们来看看JS为了支持面向对象需要解决哪些问题，都用了什么曲折的方式来解决。 没有class，用函数代替 首先JS连class关键字都没有，怎么办呢？用函数代替，JS中最不缺的就是函数，函数不仅能够执行普通功能，还能当class使用。比如我们要用JS建一个小狗的类怎么写呢？直接写一个函数就行 function Puppy() {} 这个函数可以直接用new关键字生成实例： const myPuppy = new Puppy(); 这样我们也有了一个小狗实例，但是我们没有构造函数，不能设置小狗年龄啊。 函数本身就是构造函数 当做类用的函数本身也是一个函数，而且他就是默认的构造函数。我们想让Puppy函数能够设置实例的年龄，只要让他接收参数就行了。 function Puppy(age) { this.puppyAge = age; } // 实例化时可以传年龄参数了 const myPuppy = new Puppy(2); 注意上面代码的this，被作为类使用的函数里面this总是指向实例化对象，也就是myPuppy。这么设计的目的就是让使用者可以通过构造函数给实例对象设置属性，这时候console出来看myPuppy.puppyAge就是2。 console.log(myPuppy.puppyAge); // 输出是 2 实例方法用prototype 上面我们实现了类和构造函数，但是类方法呢？Java版小狗还可以“汪汪汪”叫呢，JS版怎么办呢？JS给出的解决方案是给方法添加一个prototype属性，挂载在这上面的方法，在实例化的时候会给到实例对象。我们想要myPuppy能说话，就需要往Puppy.prototype添加说话的方法。 Puppy.prototype.say = function() { console.log(&quot;汪汪汪&quot;); } 使用new关键字产生的实例都有类的prototype上的属性和方法，我们在Puppy.prototype上添加了say方法，myPuppy就可以说话了，我么来试一下: myPuppy.say(); // 汪汪汪 实例方法查找用__proto__ 那myPuppy怎么就能够调用say方法了呢，我们把他打印出来看下，这个对象上并没有say啊，这是从哪里来的呢？ 更多内容 ","link":"https://chenmi.online/blog/post/ptototype/"},{"title":"正则表达式基础语法(够用","content":"正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。在ECMAScript中，通过RegExp类型支持正则表达式，并且采用类似Perl的简洁语法来创建： let expression = /pattern/flags pattern:任何简单或复杂的正则表达式，包括字符类、限定符、分组、先前查找和反向引用 flags：标记，用于控制正则表达式的行为 下面将介绍正则表达式的一些基本用语法： 基本匹配 一个正则表达式the，它表示一个匹配规则：由字母t开始，接着是h，再接着是e。同时正则表达式是对大小写是敏感的 &quot;the&quot; =&gt; The fat cat sat on the mat //将匹配到the 元字符 正则表达式主要依赖于元字符。元字符都有特殊的含义，或者在不同的位置时也有不同的含义 元字符 描述 . 句号匹配任意单个字符除了换行符 [] 字符种类，匹配方括号内的任意字符 [^] 否定的字符种类，匹配除了方括号内的任意字符 * 匹配&gt;=0个重复的在*号之前的字符 + 匹配&gt;=1个重复的在+号之前的字符 ? 标记?之前的字符为可选项 {n,m} 匹配num个大括号之前的字符或字符集(n&lt;=num&lt;=m) (xyz) 字符集，匹配与xyz完全相等的字符串 ｜ 或运算符，匹配符号前或后的字符 \\ 转义字符，用于匹配一些保留的字符`[] () {} . * + ? ^ $ \\ ^ 从开始行开始匹配 $ 从末端开始匹配 点运算符. &quot;.ar&quot; =&gt; The car parked in the garage. 字符集[] 方括号里面的字符集没有顺序 &quot;[Tt]he&quot; =&gt; The car parked in the garage. 方括号里面的 . 表示的就是句号 &quot;ar[.]&quot; =&gt; A garage is a good place to park a car. 否定字符集[^] &quot;[^c]ar&quot; =&gt; The car parked in the garage. 重复次数 *号：匹配&gt;=0个重复的在*号之前的字符 表达式[a-z]*匹配一行中所有以小写字母开头的字符串 &quot;[a-z]&quot; =&gt; The car parked in the garage #21. .*可以匹配所有的字符 \\s*cat\\s*匹配0或多个空格开头结尾的cat字符串 +号：匹配&gt;=1个重复的在+号之前的字符 &quot;c.+t&quot; =&gt; The fat cat sat on the mat. ?号：标记?之前的字符为可选项，即至少出现0或1次 &quot;[T]?he&quot; =&gt;The car is parked in the garage. {}号 {n,m} : 匹配num个大括号之前的字符或字符集(n&lt;=num&lt;=m) {n,} : 匹配num个大括号之前的字符或字符集(n&lt;=num) {n} : 匹配n个大括号之前的字符或字符集 (...)特征标群 (...)中包含的内容会当成一个整体，例如，表达式(ab)*匹配0个或多个出现的ab字符串，而ab*匹配的是0个或多个的b字符。同时如果在(...)使用或字符|即可以达到[]的效果，例如：(c|g|p)ar匹配car 、gar和 par与[cgp]ar等价 |或运算符 &quot;(T|t)he|car&quot; =&gt; The car is parked in the garage. 特殊转码字符 反斜线\\在表达式中用于转码紧跟后面的字符，指定 [] () {} . * + ? ^ $ \\ | 这些特殊字符 锚点 ^表示从开始行开始匹配，例如，^(T|t)he匹配以The 或the开头的字符串 $表示从末端开始匹配，例如，(at\\.)$匹配以at.结尾的字符串 简写字符集 零宽度断言(前后预查) 符号 描述 ?= 正先行断言-存在 ?! 负先行断言-排除 ?&lt;= 正后发断言-存在 ?&lt;! 负后发断言-排除 &quot;(T|t)he(?=\\sfat)&quot; =&gt; The fat cat sat on the mat. &quot;(T|t)he(?!\\sfat)&quot; =&gt; The fat cat sat on the mat. &quot;(?&lt;=(T|t)he\\s)(fat|mat)&quot; =&gt; The fat cat sat on the mat. &quot;(?&lt;!(T|t)he\\s)(cat)&quot; =&gt; The cat sat on cat. 标志 标志也称为模式修正符，可以用来修改表达式的搜索结果 标志 描述 i 忽略大小写 g 全局搜索，返回所有的匹配结果 m 多行修饰符：锚点元字符的工作范围在每行的起始 贪婪匹配与惰性匹配 正则表达式默认采用贪婪匹配模式，在该模式下会尽可能匹配长的子串，可以使用?改成惰性匹配模式 &quot;/(.*at)/&quot; =&gt; The fat cat sat on the mat. &quot;/(.*?at)/&quot; =&gt; The fat cat sat on the mat. ","link":"https://chenmi.online/blog/post/regexpBase/"},{"title":"JavaScript 生成器","content":"生成器时es6新增的一个极为灵活的结构，拥有在一个函数块内暂停和恢复代码执行的能力。这种新能力具有深远的影响，比如，使用生成器可以自定义迭代器和实现协程。 生成器基础 生成器的形式是一个函数，函数名前面加一个星号(*)表示它是一个生成器。只要能定义函数的地方，就可以定义生成器，但是箭头函数除外。 function* generatorFn() {} //生成器声明 调用生成器函数会产生一个生成器对象，生成器对象一开始处于暂停执行(suspended)的状态。与迭代器类似，生成器对象也实现了Iterator接口，因此也具有next()方法，调用这个方法可以让生成器开始或恢复执行。 function* generatorFn() {} const g = generatorFn(); console.log(g); console.log(g.next); //Object [Generator] {} //[Function: next] next()方法的返回值也有done和value属性，当函数体(生成器)为空的时候，调用一次next()就会让生成器达到done为true的状态，而默认情况下value值为undefined，可以通过return指定返回的value。 /** * 生成器对象实现了Iterator接口，它们默认的接口是自引用的 */ function* generatorFn() {} console.log(generatorFn); console.log(generatorFn()[Symbol.iterator]); console.log(generatorFn()); console.log(generatorFn()[Symbol.iterator]()); const g = generatorFn(); console.log(g === g[Symbol.iterator]()); //[GeneratorFunction: generatorFn] //[Function: [Symbol.iterator]] //Object [Generator] {} //Object [Generator] {} //true 通过yield中断执行 yield关键字可以让生成器停止和开始执行，在生成器函数遇到yield之前都会正常执行，遇到yield后会执行停止，函数作用域的状态会被保留，直到生成器对象调用next()来回复执行。 yield类似于函数的中间返回语句，它生成的值会出现在next()方法返回的对象里。 function* generatorFn() { yield 'foo'; yield 'bar'; return 'baz'; } let generatorObject = generatorFn(); console.log(generatorObject.next()); console.log(generatorObject.next()); console.log(generatorObject.next()); //{ value: 'foo', done: false } //{ value: 'bar', done: false } //{ value: 'baz', done: true } yield关键字只能在生成器函数内部使用，不能在其他地方使用，而且也不能出现在嵌套的非生成器函数中 下面举几个小用途： 生成器对象作为可迭代对象(隐式调用next()) function* generatorFn() { yield 1; yield 2; yield 3; } for(const x of generatorFn()) { console.log(x); } //1 //2 //3 使用yield实现输入和输出 yield作为函数中间参数使用：上一次让生成器函数暂停的yield会接收到传给next()的第一个值。第一次调用next()传入的值不会被使用，因为这一次调用是为了开始执行生成器函数 function* generatorFn(initial) { console.log(initial); console.log(yield); console.log(yield); } let generatorObject = generatorFn('foo'); console.log(generatorObject.next('bar')); console.log(generatorObject.next('baz')); console.log(generatorObject.next('qux')); //foo //{ value: undefined, done: false } //baz //{ value: undefined, done: false } //qux //{ value: undefined, done: true } //yield同时用于输入和输出 function* generatorFn() { return yield 'foo'; } let generatorObject = generatorFn(); console.log(generatorObject.next()); console.log(generatorObject.next('bar')); //{ value: 'foo', done: false } //{ value: 'bar', done: true } 产生迭代对象 使用星号增强yield的行为，可以迭代一个可迭代对象 function* generatorFn() { yield* [1,2,3]; } for (const x of generatorFn()) { console.log(x); } //等价的函数 //function* generatorFn() { // for(const x of [1,2,3]) { // yield x; // } //} yield*的值是关联迭代器返回done:true时的value属性。对于普通迭代器来说，这个值是undefined。对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值 function* generatorFn() { console.log('iter value:', yield*[1, 2, 3]); } for (const x of generatorFn()) { console.log('value:',x); } //value: 1 //value: 2 //value: 3 //iter value: undefined ===================================================== function* innerGeneratorFn() { yield 'foo'; return 'bar'; } function* outerGeneratorFn() { console.log('iter value:', yield* innerGeneratorFn()); } for (const x of outerGeneratorFn()) { console.log('value:', x); } //value: foo //iter value: bar 使用yield实现递归算法 yield最有用的地方是实现递归操作，此时生成器可以产生自身 /** * 生成器实现递归算法 * 相当于创建一个可迭代对象并返回递增整数 */ function* nTimes(n) { if (n &gt; 0) { yield* nTimes(n - 1); yield n - 1; } } for (const x of nTimes(3)) { console.log(x); } /** * 生成器生成随机双向图 */ class Node { constructor(id) { this.id = id; this.neighbors = new Set(); } connect(node) { if (node != this) { this.neighbors.add(node); node.neighbors.add(this); } } } class RandomGraph { constructor(size) { this.nodes = new Set(); //创建节点 for (let i = 0; i &lt; size; i++) { this.nodes.add(new Node(i)); } //随机链接节点 const threadhold = 1 / size; for (const x of this.nodes) { for (const y of this.nodes) { if (Math.random() &lt; threadhold) { x.connect(y); } } } } print() { for (const node of this.nodes) { const ids = [...node.neighbors].map((n) =&gt; n.id).join(','); console.log(`${node.id} : ${ids}`); } } } const g = new RandomGraph(6); g.print(); 生成器作为默认迭代器 class Foo { constructor() { this.values = [1, 2, 3]; } *[Symbol.iterator]() { yield* this.values; } } const f = new Foo(); for (const x of f) { console.log(x); } //1 //2 //3 for-of循环调用默认的迭代器（又是一个生成器函数），产生一个生成器对象，这个生成器对象是可迭代的 提前终止生成器 生成器可以使用return()和throw()提前终止迭代器。 return()：提供给return()方法的值，就是终止迭代器对象的值。同时只要生成器对象进入关闭状态，就无法恢复，后续调用next()会显示{done:true,value:undefined} function* generatorFn() { yield*[1, 2, 3]; } const g = generatorFn(); console.log(g); console.log(g.return(4)); console.log(g); //Object [Generator] {&lt;suspended&gt;} //{ value: 4, done: true } //Object [Generator] {&lt;closed&gt;} for-of循环等内置语言结构会忽略状态为done:true的IteratorObject内部返回的值 function* generatorFn() { yield*[1, 2, 3]; } const g = generatorFn(); for (const x of g) { if (x &gt; 1) { g.return(4); } console.log(x); } //1 //2 throw()：throw()会在暂停的时候将一个错误注入到生成器对象中。如果错误没被处理，生成器就会关闭；如果处理了这个错误，不仅不会关闭，而且还会恢复执行，但是会跳过相应的yield function* generatorFn() { for (const x of [1, 2, 3]) { try { yield x; } catch (e) {} } } const g = generatorFn(); console.log(g.next()); g.throw('foo'); console.log(g.next()); //{ value: 1, done: false } //{ value: 3, done: false } ","link":"https://chenmi.online/blog/post/generator/"},{"title":"JavaScript 迭代器","content":"在软件开发领域中，“迭代”的意思是按照顺序反复多次执行一段程序，通常会有明确的终止条件。 在es6之前用循环实现迭代的过程，通常不是很理想： 迭代之前需要事先知道如何使用数据结构。数组中的每一项都只能先通过引用取得数组对象，然后再通过[]操作符取得特定索引位置上的项。这种情况并不适用于所有的数据结构。 遍历对象并不是数据结构固有的。通过递增索引来访问数据是特定于数组类型的方式，并不适用于其他具有隐式顺序的数据结构。 在es6引入了迭代器模式，把有些数据结构称为“可迭代对象(iterable)”，同时实现Iterable接口，可以通过迭代器Iterator实现遍历。 可迭代协议(实现Iterable接口) 实现可迭代协议必须支持迭代的自我识别能力和创建实现Iterator接口对象能力。在es中，这就意味着必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的Symbol.iterator作为键。这个默认迭代器必须引用一个迭代器对象工厂函数，调用这个工厂函数必须返回一个新迭代器。 许多内置类型都实现了可迭代协议： 字符串 数组 映射 集合 arguments对象 NodeList等DOM集合对象 let str = 'abc'; console.log(str[Symbol.iterator]) //[Function: [Symbol.iterator]] //调用这个工厂函数会生成一个迭代器 console.log(str[Symbol.iterator]()) //Object [String Iterator] {} 实际写代码过程中，不需要显示调用工厂函数来生成迭代器。实现可迭代协议的所有类型都会自动创建兼容接收可迭代对象的任何语言特性。接受可迭代对象的原生语言特性包括： for-of循环 数组解构 扩展操作符 Array.from() 创建集合 创建映射 Promise.all()接收由期约组成的可迭代对象 Promise.race()接收由期约组成的可迭代对象 yield*操作符，在生成器中使用 迭代器协议 迭代器是按需创建的一次性对象，每个迭代器都会关联一个可迭代对象，同时会暴露关联的迭代对象的API。迭代器API使用next()方法可以在可迭代对象中遍历数据，同时会返回一个IteratorResult对象，其中包含迭代器返回的下一个值。 IteratoResult对象有两个属性done和value，done表示是否可以再次调用next()获取下一个值，value包含可迭代对象的下一个值。当done为true时，表示遍历结束，此时value为undefined。 注意事项： 每个迭代器都表示对可迭代对象的一次性有序遍历。不同迭代器的实例相互之间没有联系，只会独立地遍历可迭代对象 迭代器并不与可迭代对象某一时刻的快照绑定，如果可迭代对象在迭代期间被修改了，那么迭代器也会反应相应的变化 let arr = ['foo','bar']; let iter1 = arr[Symbol.iterator](); let iter2 = arr[Symbol.iterator](); console.log(iter1.next()); console.log(iter2.next()); console.log(iter2.next()); console.log(iter1.next()); //{ value: 'foo', done: false } //{ value: 'foo', done: false } //{ value: 'bar', done: false } //{ value: 'bar', done: false } let iter = arr[Symbol.iterator](); console.log(iter.next()); arr.splice(1,0,'bar'); console.log(iter.next()); console.log(iter.next()); console.log(iter.next()); // { value: 'foo', done: false } // { value: 'bar', done: false } // { value: 'bar', done: false } // { value: undefined, done: true } 自定义迭代器 与Iterable接口类似，任何实现Iterator接口的对象都可以作为迭代器使用 class Counter { constructor { this.limit = limit; } [Symbol.iterator]() { let count = 1, limit = this.limit; return { next() { if(count &lt;= limit) { return { done: false, value: count++ }; } else { return { done: true, value:undefined }; } } } } } let counter = new Counter(3); for(let i of counter) { console.log(i); } //1 //2 //3 每个以这种方式创建的迭代器也实现了Iterable接口。Symbol.iterator属性引用的工厂函数会返回相同的迭代器 提前终止迭代器 可选的return()方法用于指定在迭代器提前关闭时执行的逻辑。执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽时，就可以‘’关闭‘迭代器。可能的情况包括： for-of循环通过break，continue，return或throw提前退出 解析操作并未遍历所有值 注意事项： return()方法必须返回一个有效的IteratorResult对象。简单情况下，可以只返回{done:true} 如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代。比如：数组的迭代器就是不能关闭的 因为return()方法是可选的，所以并非所有迭代器都是可关闭的。要知道某个迭代器是否可关闭，可以测试这个迭代器实例的return属性是不是函数对象。不过，仅仅给一个不可关闭的迭代器增加这个方法并不能让它变成可关闭的。这是因为调用return()不会强制迭代器进入关闭状态。即便如此，return()方法还是会被调用 ","link":"https://chenmi.online/blog/post/iterator/"},{"title":"JavaScript --- 扩展操作符（...）","content":"参数扩展与收集 ES6新增了扩展操作符，使用它可以非常简洁地操作和组合集合数据，可以在接收参数或传递参数时使用 场景一：把数组分为单个参数（扩展参数） let arr = [25, 65, 12, 77,38]; function getsum() { //arguments伪数组会默认接收到所有参数 let sum = 0; for(let i = 0; i &lt; arguments.length; i++) { sum += arguments[i]; } } /*下面的两个操作是等价的*/ console.log(getsum(...arr)); //217 console.log(getsum(25, 65, 12, 77,38)); //217 //不只如此，您还可以这样使用,传入更多参数 console.log(getsum(3, ...arr)); //220 console.log(getsum(...arr, 45, 12)); //274 console.log(getsum(-5, ...arr, 12)); //224 console.log(getsum(...arr, ...[2, 3, 1])); //243 场景二：把参数整合为数组 （收集参数） function getsum(...values) { return values.reduce((x,y) =&gt; x + y, 0) ; //0的意思是如果数组是空的返回0，防止报错 } console.log(getsum(1,5,4)); //=&gt; 10 console.log(getsum(...[2, 56, 24, 12]); //=&gt; 94 console.log(getsum()); //=&gt; 0 以下情况需要特别注意 function getsum(...values, lastvalue) {} //这样声明会报错，因为显然lastvalue接收不到任何参数 function getsum(firstvalue, ...values) {} //这样是可以的 ———————————————— 原文链接：链接 ","link":"https://chenmi.online/blog/post/javascript-kuo-zhan-cao-zuo-fu/"},{"title":"JavaScript 深拷贝（deep copy）和浅拷贝（shallow copy）","content":"深拷贝的意思是这个新变量里的值都是从原来的变量中复制而来，并且和原来的变量没有关联。 浅拷贝的意思是，新变量中存在一些仍然与原来的变量有关联的值。 更多细节&gt;&gt;&gt;转载 ","link":"https://chenmi.online/blog/post/JavaScript的深拷贝和浅拷贝/"},{"title":"采用gridea+github搭建博客","content":"搭建的时候采用二级目录域名，配置文件要进行一些修改 采用教程GRIDEA 快速上手教程快速搭建 以我这次搭建的问题来看，网页导航栏中头像和链接跳转出现问题，通过排查，在config文件夹里的posts.json里进行下面修改（添加/blog） &quot;menus&quot;: [ { &quot;link&quot;: &quot;/blog&quot;, &quot;name&quot;: &quot;首页&quot;, &quot;openType&quot;: &quot;Internal&quot; }, { &quot;link&quot;: &quot;/blog/archives&quot;, &quot;name&quot;: &quot;归档&quot;, &quot;openType&quot;: &quot;Internal&quot; }, { &quot;link&quot;: &quot;/blog/tags&quot;, &quot;name&quot;: &quot;标签&quot;, &quot;openType&quot;: &quot;Internal&quot; }, { &quot;link&quot;: &quot;/blog/post/about&quot;, &quot;name&quot;: &quot;关于&quot;, &quot;openType&quot;: &quot;Internal&quot; } ] 在themes文件夹&gt;你采用的主题&gt;templates文件夹&gt;includes文件夹，找到header.ejs，修改下面信息（添加/blog） &lt;img class=&quot;user-avatar&quot; src=&quot;/blog/images/avatar.png&quot; alt=&quot;头像&quot;&gt; 到此博客就搭建完成了，现在等待以后的完善 ","link":"https://chenmi.online/blog/post/bulidblog/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://chenmi.online/blog/post/hello-gridea/"}]}